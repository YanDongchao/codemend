import ast
import csv
import pattern.en
import pydoc
import sqlite3
from funcsigs import signature

from softmax import softmaxed_weights_for_highlight

from codemend import relative_path, BackupHandler
from codemend.docstring_parse import doc_serve
from codemend.experimental.code_suggest.score_examples import get_effective_code_len
from codemend.experimental.func_order.func_position import FuncPositionFinder
from codemend.models.element import Element
from codemend.models.annotate_code_with_api import findCallNodes, extractCallComponents

def get_plot_commands():
  """
  Returns a list of function names that are plotting commands, as deteremined
  from the initial word of their docstrings.

  """
  pyplot_fu = get_pyplot_fu()
  # Extract plotting commands and non-plotting commands
  PLOT_PREFIXES = ['plot', 'make', 'draw']  # each happens to be 4 chars
  plot_commands = [f for f,u in pyplot_fu.items() if u[:4] in PLOT_PREFIXES]
  plot_commands = sorted(plot_commands)
  return plot_commands

def get_pyplot_fu():
  # Load csv file of pyplot summary
  pyplot_fu = {}  # [func] = utter
  print 'CodeSuggest: Loading pyplot fu...'
  with open(relative_path('docstring_parse/pyplot_fu.csv'), 'rb') as csvfile:
    reader = csv.reader(csvfile)
    next(reader, None)  # skip the header
    for f, u in reader:
      if not u:
        continue
      pyplot_fu[f] = u
  print 'CodeSuggest: read %d fu pairs'%len(pyplot_fu)

  # lowercase and tokenization of u's
  for f in pyplot_fu:
    pyplot_fu[f] = ' '.join(pattern.en.tokenize(pyplot_fu[f].lower()))
  return pyplot_fu


class CodeSuggest:
  def __init__(self):
    plot_commands = get_plot_commands()
    pyplot_fu = get_pyplot_fu()
    self.plot_commands = plot_commands
    self.nonplot_commands = [f for f in pyplot_fu.keys() if not f in plot_commands]
    print 'CodeSuggest: extracted %d plot commands'%len(plot_commands)

    # Load all code examples of plotting commands from db into memory
    # These are generated by index_examples.py
    print 'CodeSuggest: Loading code examples and pregenerated SVGs...'
    db = sqlite3.connect(relative_path('demo/data/code.sqlite3'))
    cursor = db.cursor()
    cursor.execute("SELECT func_id, code, svg FROM example")
    code_example_lookup = {}  # [func_id] = [(code, svg)]
    count_code_examples = 0
    for func_id, code, svg in cursor.fetchall():
      count_code_examples += 1
      if not func_id in code_example_lookup:
        code_example_lookup[func_id] = []
      code_example_lookup[func_id].append({'code': code, 'svg':svg})
    # Sort it again
    for func_id in code_example_lookup:
      code_example_lookup[func_id] = sorted(
        code_example_lookup[func_id],
        key=lambda x:get_effective_code_len(x['code']))
    self.code_example_lookup = code_example_lookup
    print 'CodeSuggest: Loaded %d code examples (with svgs)...'%count_code_examples
    db.close()

    # Load element_index generated by experimental/code_suggest/mine_argvs.py
    # bh = BackupHandler(relative_path('demo/data'))
    # self.element_index = bh.load('element_index')
    # print 'Loaded element_index with %d keys'%len(self.element_index)

    # Load element value counts
    bh2 = BackupHandler(relative_path('experimental/code_suggest/output/backup'))
    self.elem_val_counts = bh2.load('elem_pyplot_value_counts_0404')  # [elem][val] = count
    for elem_id in self.elem_val_counts:
      self.elem_val_counts[elem_id] = sorted(
        self.elem_val_counts[elem_id].items(), key=lambda x:-x[1])

    self.func_position_finder = FuncPositionFinder()

  def find_elems_under_cursor(self, code, cursor_line, cursor_ch, brain):
    """
    Returns a list of elements (codemend.models.Element) whose ranges match
    the cursor location. Rely on codemend.thonny.ast_utils for marking text
    ranges, which is done in brain.prepare_current_code(). This function will
    only check if the prepared context is there.

    If the context is not there, I will use Jedi. But then it will only have
    limited support, because I haven't quite figured out how to extract things
    like text ranages, value ranges, and dict as argval, etc.

    """
    elems = []
    if hasattr(brain, 'code_context') and brain.code_context:
      used_elem_objs = brain.code_context.used_elem_objs()
      for elem in used_elem_objs:
        lineno, col_offset, end_lineno, end_col_offset = elem.getTextRange()

        if '@' in elem.elem:
          if (cursor_line < lineno or cursor_line > end_lineno) or \
             (cursor_line == lineno and cursor_ch < col_offset) or \
             (cursor_line == end_lineno and cursor_ch > end_col_offset):
            continue
          elems.append(elem)
        else:
          if cursor_line >= lineno and cursor_line <= end_lineno:
            # function matching is less sensitive
            elems.append(elem)

    # add parents to matches, too -- but they will have limited support as
    # to text ranges, etc.
    matched_elem_ids = set(x.elem for x in elems)
    for elem in elems:
      for parent in doc_serve.find_parents(elem.elem):
        if parent == 'plt': continue
        matched_elem_ids.add(Element(parent, None))

    return elems

  def get_func_signature(self, elemdoc):
    if elemdoc and elemdoc.type == 'func':
      thing = pydoc.locate(elemdoc.full_name)
      if thing:
        return str(signature(thing))

  def get_repr_from_code(self, node, code_lines):
    if node.lineno == node.end_lineno:
      ret = code_lines[node.lineno - 1][node.col_offset:node.end_col_offset]
    else:
      out = []
      for i in range(node.lineno - 1, node.end_lineno):
        begin = node.col_offset if i == node.lineno - 1 else 0
        end = node.end_col_offset if i == node.end_lineno - 1 else len(code_lines[i])
        out.append(code_lines[i][begin:end])
      ret = '\n'.join(out)
    return ret

  def get_used_items_for_elem(self, elem, type_, code_lines):
    node = elem.node
    used = []
    if type_ == 'func':
      call = node
      if isinstance(call, ast.Call):
        for i, arg in enumerate(call.args):
          used.append({'key': str(i),
                       'val': self.get_repr_from_code(arg, code_lines),
                       'elem_id': elem.elem + '@' + str(i)})
        for keyword in call.keywords:
          used.append({'key': keyword.arg,
                       'val': self.get_repr_from_code(keyword.value, code_lines),
                       'elem_id': elem.elem + '@' + keyword.arg})

    elif type_ == 'arg':
      val_node = elem.val_node
      if val_node:
        if isinstance(val_node, ast.Dict):
          for keyIdx, keyObj in enumerate(val_node.keys):
            if isinstance(keyObj, ast.Str):
              key = keyObj.s
              used.append({'key': key,
                           'val': self.get_repr_from_code(val_node.values[keyIdx], code_lines),
                           'elem_id': elem.elem + '@' + key})
        elif isinstance(val_node, ast.Call) and \
             isinstance(val_node.func, ast.Name) and \
             val_node.func.id == 'dict':
          for kwarg_ in val_node.keywords:
            key = kwarg_.arg
            used.append({'key': key,
                         'val': self.get_repr_from_code(kwarg_.value, code_lines),
                         'elem_id': elem.elem + '@' + key})
    elif type_ == 'argkey':
      used.append({'val': self.get_repr_from_code(elem.val_node, code_lines)})
    return used

  def get_summary(self, query, code, cursor_line, cursor_ch, brain):
    elems = self.find_elems_under_cursor(code, cursor_line, cursor_ch, brain)
    elems = sorted(elems, key=lambda x:(len(x.elem), x.elem), reverse=True)
    summary_groups = []
    code_lines = code.split('\n')
    for elem in elems:
      elem_id = elem.elem
      elemdoc = doc_serve.find_elem(elem_id)
      if not elemdoc: continue
      summary = {}
      summary['name'] = elemdoc.full_name.replace('matplotlib.', '')
      summary['elem_id'] = elem_id
      summary['val'] = elemdoc.name
      summary['docstring'] = elemdoc.utter_expand
      if not elemdoc.utter_expand:
        thing = pydoc.locate(elemdoc.full_name)
        if thing:
          summary['docstring'] = pydoc.html.document(thing)
      summary['signature'] = self.get_func_signature(elemdoc)  # only valid for func
      summary['val_text_range'] = elem.getValueTextRange()  # only valid for arg and argkey
      used_items = self.get_used_items_for_elem(elem, elemdoc.type, code_lines)  # valid for all
      summary['suggest'] = self.get_suggest(query, code, cursor_line, cursor_ch, brain, elem_id, used_items, elem)
      summary['type'] = elemdoc.type
      summary_groups.append(summary)

    # A made-up summary, just for suggesting functions.
    summary = {}
    summary['name'] = 'TOP_MODULE'
    summary['elem_id'] = 'TOP_MODULE'
    summary['val'] = 'TOP_MODULE'
    summary['suggest'] = self.get_suggest(query, code, cursor_line, cursor_ch, brain, 'TOP_MODULE')
    summary_groups.append(summary)

    return summary_groups

  def get_suggest(self, query, code, cursor_line, cursor_ch, brain, mother_elem_id, used_items=None, mother_elem=None):
    """
    Depending on the mother_elem_id, will return different suggestions.

    Returns
    -------
    A suggest object, with name, items, etc.

    """
    if mother_elem_id == 'TOP_MODULE':
      return self.get_func_suggests(query, code, brain)

    # Order is important. Preventing false suggesting functions where it is
    # really an argument.
    suggest = self.get_argval_suggests(code, mother_elem_id, cursor_line, used_items)
    if suggest:
      return suggest

    suggest = self.get_arg_suggests(query, code, mother_elem_id, brain, used_items, mother_elem)
    if suggest:
      return suggest

  def _rank_suggest_candidates(self, suggests, query, brain):
    """
    Returns a list of ranked suggests.

    """
    used_elems = brain.code_context.used_elems()
    cand_elems = [x['elem_id'] for x in suggests]
    elem_scores = brain.bimodal.model.score(query, used_elems, cand_elems)
    # elem_scores = brain.w2vb.score(query, used_elems, cand_elems)
    elem_scores = softmaxed_weights_for_highlight(elem_scores)
    weight_lookup = dict(elem_scores)  # [elem_id] = weight
    for item in suggests:
      if item['elem_id'] in weight_lookup:
        item['weight'] = weight_lookup[item['elem_id']]
    if query:
      suggests = sorted(suggests, key=lambda x:-x['weight'])
    else:
      # model ranking without query is quite unreliable
      suggests = sorted(suggests, key=lambda x:-x['count'])
    return suggests

  def get_func_suggests(self, query, code, brain):
    """
    Returns a group of suggested functions to call.

    Since the suggestion of functions is independent of the cursor position,
    so this is also used for suggesting functions without NL query.

    """
    # First, try to obtain a list of called pyplot plotting commands
    called_plotting_commands = set()
    called_funcs = set()
    if code.strip():
      node = ast.parse(code)
      calls = findCallNodes(node)
      call_components = [extractCallComponents(call) for call in calls]
      called_funcs |= set(x[0] for x in call_components)
      called_plotting_commands = set(f for f in called_funcs if f in self.plot_commands)

    # Second, prepare candidate functions.
    candidates = self.nonplot_commands if called_plotting_commands else self.plot_commands
    candidates = filter(lambda x: x not in called_funcs, candidates)
    suggest_mode = 'non_terminal' if called_plotting_commands else 'gallery'
    suggests = []
    for f in candidates:
      if f in ['subplot2grid', 'show', 'gca', 'close', 'rc']:
        # manually filtering irrelevant functions
        continue
      elemdoc = doc_serve.find_elem('plt.' + f)
      assert elemdoc, f
      suggest = {}
      suggest['val'] = elemdoc.name
      suggest['weight'] = 0.
      suggest['doc'] = elemdoc.utter_expand
      suggest['elem_id'] = elemdoc.elem_id
      suggest['count'] = int(elemdoc.count)
      suggest['mode'] = suggest_mode
      suggest['signature'] = self.get_func_signature(elemdoc)
      suggests.append(suggest)

    # Third, apply model to rank candidates.
    suggests = self._rank_suggest_candidates(suggests, query, brain)

    # Attach code examples
    for item in suggests:
      if item['val'] in self.code_example_lookup:
        item['examples'] = self.code_example_lookup[item['val']]

    return {'name': 'pyplot functions',
            'items': suggests,
            # 'mode': suggest_mode,
            'type': 'functions',
            'elem_id': 'TOP_MODULE'}

  def get_arg_suggests(self, query, code, elem_id, brain, used_items=None, mother_elem=None):
    assert isinstance(elem_id, basestring)
    if not elem_id: return None
    elemdoc = doc_serve.find_elem(elem_id)
    if not elemdoc: return None
    if elemdoc.type not in ('func', 'arg'): return None
    is_to_insert = (used_items is None)
    if used_items: assert mother_elem  # both need to be supplied at the same time

    # Prepare candidates
    suggests = []
    suggest_lookup = {}  # [elem_name] = idx
    for child in doc_serve.find_children(elem_id):
      if child.type in ('arg', 'argkey'):
        suggest = {
          'val': child.name,
          'weight': 0.,
          'doc': child.utter_expand,
          'elem_id': child.elem_id,
          'count': int(child.count),
          'mode': 'non_terminal',
          'used_val': None,
        }
        suggest_lookup[child.name] = len(suggests)
        suggests.append(suggest)

    if used_items:  # for function call preview of existing called function.
      for item in used_items:
        if item['key'] in suggest_lookup:
          suggests[suggest_lookup[item['key']]]['used_val'] = item['val']
        else:
          # This arg or dict-argkey is used but not in our documentation. So create one.
          suggest = {
            'val': item['key'],
            'weight': 0.,
            'doc': '',
            'elem_id': item['elem_id'],
            'count': 0,
            'mode': 'non_terminal',
            'used_val': item['val']
          }
          suggests.append(suggest)

    # Rank suggests
    suggests = self._rank_suggest_candidates(suggests, query, brain)

    out = {'name':'parameters of "%s"'%(elem_id if elemdoc.type == 'func' else elemdoc.name),
            'items':suggests,
            # 'mode':'non_terminal',
            'type':'parameters',
            'elem_id': elem_id,
            'elem_name': elemdoc.name,
            'mother_elem_type': elemdoc.type,
            'is_to_insert': is_to_insert}

    if elemdoc.type == 'func':
      # Find the best position to insert the func
      positions = self.func_position_finder.findPositions(code, elemdoc.name)  # [(lineno, score)]
      best_position = sorted(positions, key=lambda x:(x[1], x[0])
                            )[-1][0] if positions else 9999
      out['positions'] = positions
      out['best_position'] = best_position

    if mother_elem:
      out['mother_text_range'] = mother_elem.getTextRange();

    return out

  def get_argval_suggests(self, code, elem_id, cursor_line, used_items=None):
    assert isinstance(elem_id, basestring)
    if not elem_id: return None
    elemdoc = doc_serve.find_elem(elem_id)
    if not elemdoc: return None
    if elemdoc.type not in ('arg', 'argkey'): return None
    if not elem_id in self.elem_val_counts: return None
    val_counts = self.elem_val_counts[elem_id]
    val_counts = filter(lambda x: '$' not in x[0], val_counts)
    val_counts = val_counts[:30]
    count_sum = sum(x[1] for x in val_counts)
    val_freqs = [(val, count / (count_sum+0.1)) for (val, count) in val_counts]
    val_scores = softmaxed_weights_for_highlight(val_freqs)
    suggests = [{'val': val, 'weight': weight, 'doc': '', 'elem_id': val, 'mode': 'terminal'}
                for (val, weight) in val_scores]
    return {'name': 'values of "%s"'%elem_id,
            'items': suggests,
            #'mode': 'terminal',
            'type': 'values',
            'elem_id': elem_id}


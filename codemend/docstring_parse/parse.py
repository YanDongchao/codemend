"""Parse XML generated by Sphinx.

To generate the XMLs of API docs using Sphinx, see wiki:

    https://github.com/ronxin/codemend/wiki/Generating-XMLs-of-API-docs-using-Sphinx

This script requires lxml parser. To install::

    easy_install lxml

"""
from bs4 import BeautifulSoup
import os
import sqlite3
import sys
import pattern.en

KEYWORDS = set("""keyword keywords argument arguments option
               options kwargs **kwargs property properties""".split())

class XMLDirParser:
  def __init__(self, db):
    self.db = db
    self.cursor = db.cursor()

  def isDone(self, f):
    """Returns True if the current file is marked done in the
    sqlite table."""
    self.cursor.execute('SELECT * FROM finished WHERE file = ?', (f,))
    row = self.cursor.fetchone()
    return True if row else False

  def markDone(self, f):
    """Marks a file to be done. So that next time wouldn't need
    to repeat processing it."""
    self.cursor.execute('INSERT OR IGNORE INTO finished VALUES (?)', (f,))
    self.db.commit()

  def processXmlFolder(self, xml_dir):
    xml_files = [os.path.join(xml_dir, f) for f in os.listdir(xml_dir)]
    xml_files = filter(os.path.isfile, xml_files)
    xml_files = filter(lambda x: x.endswith('.xml'), xml_files)

    self.cursor.executescript("""
      CREATE TABLE IF NOT EXISTS finished (
        file TEXT PRIMARY KEY NOT NULL);

      CREATE TABLE IF NOT EXISTS reference (
        func_id TEXT NOT NULL,
        ref TEXT NOT NULL
        );
      CREATE INDEX IF NOT EXISTS func_id_idx ON reference(func_id);
      CREATE INDEX IF NOT EXISTS ref_idx ON reference(ref);

      CREATE TABLE IF NOT EXISTS mapping (
        func_id TEXT NOT NULL,
        arg TEXT,  /* This can be NULL for function-level utterances */
        utter TEXT
        );
      CREATE INDEX IF NOT EXISTS func_id_idx on mapping(func_id);
      CREATE INDEX IF NOT EXISTS arg_idx on mapping(arg);
      """)
    self.db.commit()

    for f in xml_files:
      f_basename = os.path.basename(f)
      if self.isDone(f_basename):
        print '%s marked done - skipped'%f
        continue
      self.processXmlFile(f)
      self.markDone(f_basename)

  def processXmlFile(self, xml_file):
    """Do initial processing of an XML file, and use the extracted information
    to populate the reference and mapping tables."""
    xml_file_basename = os.path.basename(xml_file)

    with open(xml_file) as reader:
      xml_str = reader.read()

    """This is necessary since bs4 somehow silently eats space
    after this tag."""
    xml_str = xml_str.replace('</reference>', '</reference>\n')
    xml_str = xml_str.replace('</emphasis>', '</emphasis>\n')

    soup = BeautifulSoup(xml_str, 'xml')  # equivalent to : 'lxml-xml'

    ret = self.extractFunctionLevelUtterances(soup)
    print '%s - %d (func_id, utter) extracted from first-paragraph tags'%(xml_file_basename, ret)

    ret = self.extractArgsFromNumpydocStyleFields(soup)
    print '%s - %d (func_id, arg, utter) extracted from numpydoc-style fields'%(xml_file_basename, ret[0])
    print '%s - %d (func_id, ref) extracted from numpydoc-style fields'%(xml_file_basename, ret[1])

    ret = self.extractMoreForSituation1(soup)
    print '%s - %d (func_id, ref) extracted from Situation 1 (Inline kw + ref)'%(xml_file_basename, ret)

    ret = self.extractMoreForSituation2(soup)
    print '%s - %d (func_id, ref) extracted from Situation 2 (Table)'%(xml_file_basename, ret)

    ret = self.extractMoreForSituation3(soup)
    print '%s - %d (func_id, arg, utter) extracted from Situation 3 (definition_list)'%(xml_file_basename, ret)

    ret = self.extractMoreForSituation4(soup)
    print '%s - %d (func_id, arg, utter) extracted from Situation 4 (definition_list)'%(xml_file_basename, ret)

    print '\n'

  def extractFunctionLevelUtterances(self, soup):
    """Populates the `mapping` table."""
    out = []  # (func_id, utterance)
    descs = soup.findAll('desc', {'desctype':['method','function']})
    for d in descs:
      func_id = d.find('desc_signature').attrs['ids']
      p = d.find('desc_content').find('paragraph')
      if not p: continue
      s = ' '.join(p.getText().split())
      if s.startswith('ACCEPTS'):
        """If the first sentence in desc_content is ACCEPTS, then
        there is no useful NL utterance for that function.
           e.g., matplotlib.axes.Axes.set_adjustable
        In such cases, we simply ignore these functions.
        """
        continue

      if s.lower().startswith('call signature:'):
        """If the first paragraph is call signature: then look up
        the next paragraph."""
        p = p.findNext('paragraph')
        if p:
          s = ' '.join(p.text.split())

      """The NL description should stop before the semicolon:
        e.g., matplotlib.axes.Axes.set_xscale
         Except:
         matplotlib.axes.Axes.set_figure
      """
      s.replace(' class:', ' class')
      s = s.split(':', 1)[0]

      """The NL description should contain only the first sentence."""
      sentences = pattern.en.tokenize(s)
      if not sentences: continue
      s = sentences[0]
      out.append((func_id, s))

    # Only execute. Hold on committing until everything is done for this file.
    for func_id, utter in out:
      self.cursor.execute('INSERT INTO mapping VALUES (?, NULL, ?)', (func_id, utter))

    return len(out)

  def extractArgsFromNumpydocStyleFields(self, soup):
    """Try analyze all "Parameters" Fields written following numpydoc styles.
    The numpydoc styles are those that look like:

    Parameters
    ----------
    blah
    blah

    Other Parameters
    ----------------
    blah
    blah

    Will populate both `mapping` and `reference` tables.
    """
    out = []  # [(func_id, arg, utterance)]
    out_refs = []  # [(func_id, ref)]
    # pfn: parameter field name
    for pfn in soup.findAll('field_name', text = lambda x:x.lower() in [
                            'parameters', 'other parameters']):
      pfb = pfn.findNextSibling()
      assert pfb.name == 'field_body'
      p = pfb.find('paragraph')
      func_id = self.getCurrentFunctionID(p)
      while p:
        assert p.name == 'paragraph'
        strong = p.find('strong')
        if strong:
          arg = strong.getText().strip()
          sibling = p.findNextSibling()
          if sibling and sibling.name == 'block_quote':
            block_quote = sibling
            p_utter = block_quote.find('paragraph')
            utter = self.getTokenizedTextFromParagrpah(p_utter)
            out.append((func_id, arg, utter))
        p = p.findNextSibling('paragraph')

      # Handle cases where other class/method are referenced in "other parameters"
      if pfn.text.lower() == 'other parameters':
        ref = pfb.find('reference')
        if ref and ref.has_attr('reftitle'):
          reftitle = ref.attrs['reftitle']
          out_refs.append((func_id, reftitle))

    for func_id, arg, utter in out:
      self.cursor.execute('INSERT INTO mapping VALUES (?,?,?)', (func_id, arg, utter))

    for func_id, ref in out_refs:
      self.cursor.execute('INSERT INTO reference VALUES (?,?)', (func_id, ref))

    return len(out), len(out_refs)

  def extractMoreForSituation1(self, soup):
    """
    Situation 1: Inline keyword + reference (e.g., loglog)

    Extracts foreign class/method references

    See the following notebook for details:
      https://github.com/ronxin/codemend/blob/master/docstring_parse/soup.ipynb
    """
    out_refs = []
    for p in soup.findAll('paragraph'):
      if not self.isDescTypeOkay(p): continue
      func_id = self.getCurrentFunctionID(p)
      ref_tags = p.findAll('reference')
      for r in ref_tags:
        if not r.has_attr('reftitle'):
          # Some "internal references" do not have reftitle
          continue
        reftitle = r.attrs['reftitle']
        assert reftitle, 'ref_tag=%s, current_func=%s'%(r, func_id)
        if not self.paragraphMentionsKeyword(p): continue
        out_refs.append((func_id, reftitle))

    for func_id, ref in out_refs:
      self.cursor.execute('INSERT INTO reference VALUES (?,?)', (func_id, ref))

    return len(out_refs)

  def extractMoreForSituation2(self, soup):
    """
    Situation 2: Table

    Extracts foreign class/method references

    See the following notebook for details:
      https://github.com/ronxin/codemend/blob/master/docstring_parse/soup.ipynb
    """
    out_refs = []  # (func_id, ref)
    for p in soup.findAll('table'):
      if not self.isDescTypeOkay(p): continue
      func_id = self.getCurrentFunctionID(p)
      parent = p.findParent()
      if not parent.name == 'block_quote': continue
      pps = parent.findPreviousSibling()
      if not pps: continue
      if not pps.name == 'paragraph': continue
      if not self.paragraphMentionsKeyword(pps): continue
      thead = p.find('thead')
      assert thead
      entries = thead.findAll('entry')
      if not len(entries) == 2: continue
      e1,e2 = map(lambda x:x.getText().lower().strip(), entries)
      if not e1 == 'property': continue
      if not e2 == 'description': continue
      tbody = p.find('tbody')
      assert tbody
      references = tbody.findAll('reference')
      for r in references:
        out_refs.append((func_id, r.attrs['reftitle']))

    for func_id, ref in out_refs:
      self.cursor.execute('INSERT INTO reference VALUES (?,?)', (func_id, ref))

    return len(out_refs)

  def extractMoreForSituation3(self, soup):
    """Situation 3: definition_list

    Extracts own keyword arguments from messy formats.

    See the following notebook for details:
      https://github.com/ronxin/codemend/blob/master/docstring_parse/soup.ipynb
    """
    out = []  # [(func_id, arg, utterance)]
    for p in soup.findAll('definition_list'):
      if not self.isDescTypeOkay(p): continue
      func_id = self.getCurrentFunctionID(p)
      parent = p.findParent()
      if not parent.name == 'block_quote': continue
      pps = parent.findPreviousSibling()
      if not pps: continue
      if not pps.name == 'paragraph': continue
      pps_qualified = False
      if pps == pps.findParent('desc_content').find('paragraph'):
        # The first paragraph within the current desc_content
        pps_qualified = True
      elif self.paragraphMentionsKeyword(pps):
        pps_qualified = True
      elif pps.findParent().name == 'definition':
        pps2 = pps.findParent().findPreviousSibling()
        if pps2.name == 'term' and self.paragraphMentionsKeyword(pps2):
          pps_qualified = True
      if pps_qualified:
        for dli in p.findAll('definition_list_item'):
          utter = self.getTokenizedTextFromParagrpah(dli.find('definition'))
          for arg in dli.find('term').findAll('emphasis'):
            arg = arg.getText().strip()
            out.append((func_id, arg, utter))

    for func_id, arg, utter in out:
      self.cursor.execute('INSERT INTO mapping VALUES (?,?,?)', (func_id, arg, utter))

    return len(out)

  def extractMoreForSituation4(self, soup):
    """Situation 4: inline emphasis scenario

    Extracts own keyword arguments from messy formats.

    See the following notebook for details:
      https://github.com/ronxin/codemend/blob/master/docstring_parse/soup.ipynb
    """
    out = []   # [(func_id, arg, utterance)]
    for p in soup.findAll('emphasis'):
      if not self.isDescTypeOkay(p): continue
      func_id = self.getCurrentFunctionID(p)
      ptext = p.getText().strip()
      if ptext in ['None', 'True', 'False', 'self']: continue
      if 'kwargs' in ptext: continue
      parent = p.findParent()
      if not parent: continue
      if parent.name != 'paragraph': continue
      pp = parent.findParent()
      if not pp: continue
      if pp.name != 'desc_content': continue
      if p == pp.find('paragraph'): continue
      utter = self.getTokenizedTextFromParagrpah(parent)
      out.append((func_id, ptext, utter))

    for func_id, arg, utter in out:
      self.cursor.execute('INSERT INTO mapping VALUES (?,?,?)', (func_id, arg, utter))

    return len(out)

  def getTokenizedTextFromParagrpah(self, p, first_sentence_only=True):
    """Supports any type of elements, not only paragraphs."""
    text = p.getText()
    sentences = pattern.en.tokenize(text)
    if first_sentence_only:
      sentences = sentences[:1]
    return ' '.join(sentences)

  def paragraphMentionsKeyword(self, p):
    text = self.getTokenizedTextFromParagrpah(p)
    tokens = text.split()
    return len(set(tokens).intersection(KEYWORDS)) > 0

  def getCurrentFunctionID(self, p):
    """Given a paragraph, get the current function ID.
    Supports any type of elements, not just paragraphs."""
    dc = p.findParent('desc_content')
    ds = dc.findPreviousSibling()
    assert ds.name == 'desc_signature'
    assert ds.has_attr('ids')
    return ds.attrs['ids']

  def getDescType(self, p):
    d = p.findParent('desc')
    if not d: return None
    assert d.has_attr('desctype')
    return d.attrs['desctype']

  def isDescTypeOkay(self, p):
    desc_type = self.getDescType(p)
    return desc_type in ['method', 'function']

def main():
  """
  Usage:
    - argv[1]: directory of API XMLs

  For testing, use

    python parse.py .

  and the .xml file in this current folder will be used.

  For real use:
  [Windows] python parse.py C:\\Users\\Xin\\Dropbox\\git\\matplotlib\\doc\\build\\xml\\api
  [Mac] python parse.py /Users/ronxin/Dropbox/git/matplotlib/doc/build/xml/api
  """
  if len(sys.argv) < 2:
    print main.__doc__
    sys.exit()

  xml_dir = sys.argv[1]

  # For result caching
  # This will create the file if it does not exist
  db = sqlite3.connect('api.sqlite3')
  parser = XMLDirParser(db)
  try:
    parser.processXmlFolder(xml_dir)
  finally:
    db.close()

if __name__ == '__main__':
  main()

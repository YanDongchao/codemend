"""
Extract and generate intermediate output file
from matplotlib plotting cookbook's HTML export. The export must be
generated by Mac's old Adobe Acrobat.

This code is supposed to run in ~/Dropbox/ProjectS/data/

"""

with open('matplotlib-cookbook/html-mac-noimage/matplotlib Plotting Cookbook.html') as reader:
  lines = reader.readlines()

lines = map(lambda x:x.decode('utf-8'), lines)
lines = map(lambda x:x.strip(), lines)
lines = filter(lambda x:x, lines)

import re
from HTMLParser import HTMLParser
parser = HTMLParser()
lines = map(lambda x:parser.unescape(x), lines)
lines = map(lambda x:re.sub(r'<u>\s+</u>','__',x), lines)

# All content is in the last line
content = lines[-1]

"""We are looking for three types of <p></p>
1. class=s25: title
2. class=None: content
3. class=s22: code
"""

match = re.findall(r'<p(.*?)>(.*?)</p>', content)

tagps = []  # [(tag, p)]
for m1,m2 in match:
  m1 = m1.strip()
  if m1 == 'class="s25"':
    tagps.append(('TITL', m2))
  elif m1 == 'class="s22"':
    tagps.append(('CODE', m2))
  elif not m1:
    tagps.append(('CTNT', m2))

# Go through the p's and concatenate

segs = []  # [(tag, seg)]
last_tag = ''
last_ps = []
tagps.append(('',''))
for tag, p in tagps:
  if tag != last_tag:
    if last_ps:
      segs.append((last_tag, '\n'.join(last_ps)))
      last_ps = []
  last_tag = tag
  last_ps.append(p)

# c = 0
# for tag, seg in segs:
#   print 'TAG=%s'%tag
#   print seg
#   print '\n\n\n'
#   c += 1
#   if c == 100:
#     break

# Read in the plain text version of the code
# I used "accessible" mode when exporting pdf as txt
with open('matplotlib-cookbook/text-accessible/matplotlib Plotting Cookbook.txt') as reader:
  lines = reader.readlines()

# !!NOTE
# NOTE: need to use Sublime to open the txt, and "Save as Encoding" -> UTF-8
lines = map(lambda x:x.decode('utf-8'), lines)
lines = lines[0].split('\r')
# CRITICAL: do not use strip, we want to preserve left space
lines = map(lambda x:x.rstrip(), lines)

chars = []
offsets = []
for line in lines:
  line = re.sub(r'\s', '', line)
  chars += list(line)
  offsets.append(len(chars))

charseq = ''.join(chars)

count = 0
success = 0
import bisect
import ast
for i, (tag, seg) in enumerate(segs):
  if tag == 'CODE':
    count += 1
    segcharseq = re.sub(r'\s', '', seg)
    try:
      start = charseq.index(segcharseq)
      end = start + len(segcharseq)
      start_li = bisect.bisect(offsets, start)
      end_li = bisect.bisect(offsets, end)

      matched_lines = lines[start_li:end_li]

      # unwrap some super-long lines due to book printing limit
      matched_concat = '\n'.join(matched_lines)
      matched_breaks = matched_concat.split('\n\n')
      matched_breaks = map(lambda x:x.replace('\n',''), matched_breaks)
      cleaned_code = '\n'.join(matched_breaks).lstrip()

      segs[i] = (tag, cleaned_code)

      _ = ast.parse(cleaned_code)
      success += 1
    except:
      pass

print count, success
# 207 total code segments
# 203 matched to correct txt format
# 71  parseable -- Before matching to txt and cleaning
# 170 parseable -- after matching and cleaning -- not bad at all!!


# Further clean up titles and contents
import html2plain  # see consim/py/lib/README
def html2plaintext(input_string):
  return html2plain.strip_tags(input_string)
def cleanTitle(title):
  return html2plaintext(title).replace('\n', ' ')
def cleanContent(s):
    s = re.sub(r'<a.*?</a>', ' ', s)
    s = html2plaintext(s)
    s = s.lower()
    return s

for i, (tag, seg) in enumerate(segs):
  if tag == 'TITL':
    seg = cleanTitle(seg).strip()
    segs[i] = (tag, seg)
  elif tag == 'CTNT':
    seg = cleanContent(seg).strip()
    segs[i] = (tag, seg)

segs = filter(lambda x:x[1], segs)

# Some code segments may be concated now. So do the concat again
segs2 = []  # [(tag, seg)]
last_tag = ''
last_segs = []
segs.append(('',''))
for tag, seg in segs:
  if tag != last_tag:
    if last_segs:
      segs2.append((last_tag, '\n'.join(last_segs)))
      last_segs = []
  last_tag = tag
  last_segs.append(seg)

segs = segs2
del segs2

print 'There are %d CODEs after merging.'%len(filter(lambda x:x[0]=='CODE', segs))
print 'How many of them are parseable?'
success = 0
for tag, seg in segs:
  if tag != 'CODE': continue
  try:
    _ = ast.parse(seg)
    success += 1
  except SyntaxError:
    pass
print 'The answer is %d'%success

import backup_util as bu
bh = bu.BackupHandler('.')
bh.save('cookbook_segs', segs)

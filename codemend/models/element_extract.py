"""
Extracts elements from source code.

With the following features:
 - Trace local dependencies.
 - Trace module aliases resulted from import-as expressions.
 - [TODO] Tolerate moderate syntax errors.

Limitations:
 - limited support for control structures (while, if, for, switch, etc.).

"""
import ast
from textwrap import dedent

from codemend.models.default_varmap import default_var_map  # automatically generated by default_varmap_gen.py
from codemend.models.element import Element

def extract_varmap_elems(code, load_default_varmap=True, import_only=False):
  """
  Returns (var_map, elems)

  No simplification or normalization is done.

  Parameters
  ----------
  - code: can be a string or a parsed AST node.
  - marge_range: only useful for real-time serving

  """
  if isinstance(code, ast.Module):
    module_node = code
  else:
    module_node = ast.parse(code)
  var_map = default_var_map if load_default_varmap else {}  # [name] = element
  elems = []
  exec_module(module_node, var_map, elems, import_only)
  return var_map, elems

def exec_module(module_node, var_map, elems, import_only):
  class StatementFinder(ast.NodeVisitor):
    """Find all executable statements."""
    def __init__(self):
      self._nodes = []

    def visit_Expr(self, node):
      self._nodes.append(node)

    def visit_Assign(self, node):
      self._nodes.append(node)

    def visit_Import(self, node):
      self._nodes.append(node)

    def visit_ImportFrom(self, node):
      self._nodes.append(node)

    def get(self):
      return self._nodes

  finder = StatementFinder()
  finder.visit(module_node)
  nodes = finder.get()
  for node in nodes:
    exec_node(node, var_map, elems, import_only)

def exec_node(node, var_map, elems, import_only):
  assert isinstance(node, ast.Expr) \
         or isinstance(node, ast.Assign) \
         or isinstance(node, ast.Import) \
         or isinstance(node, ast.ImportFrom)

  if isinstance(node, ast.Import):
    for alias in node.names:
      if alias.asname:
        # Limitation: not resolving alias.name
        var_map[alias.asname] = alias.name

  elif isinstance(node, ast.ImportFrom):
    module = node.module
    if module:
      # module could be None, e.g., "from . import xyz"
      for alias in node.names:
        if alias.asname:
          # Limitation: not resolving alias.name
          var_map[alias.asname] = module + '.' + alias.name
        else:
          var_map[alias.name] = module + '.' + alias.name

  else:
    if import_only: return
    calls = findGeneralCallNodes(node)
    for call in calls:
      for elem in call2elem(call, var_map, False):
        elems.append(elem)

    if isinstance(node, ast.Assign):
      targets = node.targets
      if calls:
        # Limitation: only one call is processed per statememt
        # this means we don't support anything like: z = f(x) + g(y)
        call = calls[0]

        elem = call2elem(call, var_map, True)
        for target in targets:
          # Limitation: the same rtype will be assigned to multiple targets.
          # This means we may screw up for something like:
          #    fig, axes = plt.subplots()
          if isinstance(target, ast.Name):
            var_map[target.id] = elem

def call2elem(call, var_map, ignore_keyword):
  """
  Parameters
  ----------
  - call: a general call node as found by findGeneralCallNodes().
  - ignore_keyword:
    - if False: returns a list of elements, including the call
      itself and one for every argument.
    - if True: returns just an element representing the call itself.

  """
  head = node2head(call, var_map)

  if ignore_keyword:
    return head
  else:
    elems = [Element(head, call)]
    if isinstance(call, ast.Call):
      for i, arg in enumerate(call.args):
        elem_id = '%s@%d'%(head, i)
        elems.append(Element(elem_id, arg, arg, call))
        _try_extract_dict_argvals(arg, elems, elem_id, call)

      for keyword in call.keywords:
        elem_id = '%s@%s'%(head, keyword.arg)
        elems.append(Element(elem_id, keyword, keyword.value, call))
        _try_extract_dict_argvals(keyword.value, elems, elem_id, call)

    return elems

def _try_extract_dict_argvals(node, elems, prefix, parent_node):
  # handles dict as argval or kwargval
  if isinstance(node, ast.Dict):
    # plt.title({'foo': 'bar'})
    for keyIdx, keyObj in enumerate(node.keys):
      if isinstance(keyObj, ast.Str):
        key = keyObj.s
        elems.append(Element('%s@%s'%(prefix, key), keyObj, node.values[keyIdx], parent_node))
  elif isinstance(node, ast.Call) and \
       isinstance(node.func, ast.Name) and \
       node.func.id == 'dict':
    # plt.title(dict(foo: 'bar'})
    for kwarg_ in node.keywords:
      key = kwarg_.arg
      elems.append(Element('%s@%s'%(prefix, key), kwarg_, kwarg_.value, parent_node))

def node2head(node, var_map):
  """
  Given a node, returns the name of its head. Reference to local variables or
  aliases will be resolved.

  Recursive search until reaching the root.

  e.g., plt.plot()  -->  plt.plot

  """
  if isinstance(node, ast.Call):
    return node2head(node.func, var_map)
  elif isinstance(node, ast.Subscript):
    return node2head(node.value, var_map)
  elif isinstance(node, ast.Attribute):
    assert isinstance(node.attr, basestring), node.attr
    return node2head(node.value, var_map) + '.' + node.attr
  elif isinstance(node, ast.Name):
    assert isinstance(node.id, basestring), node.id
    if node.id in var_map:
      return var_map[node.id]
    else:
      return node.id
  else:
    # e.g., 'abc'.split('b') => Str.split
    return node.__class__.__name__


def findGeneralCallNodes(node):
  """
  Returns an array of any of the following:
  - Call
  - Subscript
  - Attribute

  No recursive search is done.

  """
  class GeneralCallFinder(ast.NodeVisitor):
    def __init__(self):
      self._nodes = []

    def visit_Call(self, node):
      self._nodes.append(node)

    def visit_Subscript(self, node):
      self._nodes.append(node)

    def visit_Attribute(self, node):
      self._nodes.append(node)

    def get(self):
      return self._nodes

  gcf = GeneralCallFinder()
  gcf.visit(node)
  return gcf.get()

if __name__ == '__main__':
  code = dedent('''
    import matplotlib.pyplot as X
    X.plot([1,2], [1,3], s="red")
    a = X.gca().spines["top"].set_visible(
            False, bbox={"t":"w"}, font=dict(x="c"))
    a.set_title({'a':'b'})''')
  var_map, elems = extract_varmap_elems(code)
  for elem in elems:
    print 'Line %d: %s'%(elem.lineno, elem.elem)
